//------------------------------------------------------------------------
// 简称: TurtleTrader
// 名称: 海龟交易系统
// 类别: 公式应用
// 类型: 内建应用
//------------------------------------------------------------------------

Params
    Numeric RiskRatio(1);                   // % Risk Per N ( 0 - 100)
    Numeric ATRLength(20);                  // 平均波动周期 ATR Length
    Numeric boLength(20);                   // 短周期 BreakOut Length
    Numeric fsLength(55);                   // 长周期 FailSafe Length
    Numeric teLength(10);                   // 离市周期 Trailing Exit Length
    Bool LastProfitableTradeFilter(True);   // 使用入市过滤条件
Vars
    Numeric MinPoint;                       // 最小变动单位
    NumericSeries AvgTR;                    // ATR
    Numeric N;                              // N 值
    Numeric TotalEquity;                    // 按最新收盘价计算出的总资产
    Numeric TurtleUnits;                    // 交易单位
    NumericSeries DonchianHi;               // 唐奇安通道上轨，延后1个Bar
    NumericSeries DonchianLo;               // 唐奇安通道下轨，延后1个Bar
    NumericSeries fsDonchianHi;             // 唐奇安通道上轨，延后1个Bar，长周期
    NumericSeries fsDonchianLo;             // 唐奇安通道下轨，延后1个Bar，长周期
    Numeric ExitHighestPrice;               // 离市时判断需要的N周期最高价
    Numeric ExitLowestPrice;                // 离市时判断需要的N周期最低价
    Numeric myEntryPrice;                   // 开仓价格
    Numeric myExitPrice;                    // 平仓价格
    Bool SendOrderThisBar(False);           // 当前Bar有过交易
    NumericSeries preEntryPrice(0);         // 前一次开仓的价格
    BoolSeries PreBreakoutFailure(false);   // 前一次突破是否失败
Begin
    // 集合竞价过滤
    if (!CallAuctionFilter()) return;

    If(BarStatus == 0)
    {
        preEntryPrice = InvalidNumeric;
        PreBreakoutFailure = false;
    }

    MinPoint = MinMove*PriceScale;
    AvgTR = XAverage(TrueRange,ATRLength);
    N = AvgTR[1];
    TotalEquity = Portfolio_CurrentCapital() + Portfolio_UsedMargin();
    TurtleUnits = (TotalEquity*RiskRatio/100) /(N * ContractUnit()*BigPointValue());
    TurtleUnits = IntPart(TurtleUnits); // 对小数取整

    DonchianHi = HighestFC(High[1],boLength);
    DonchianLo = LowestFC(Low[1],boLength);

    fsDonchianHi = HighestFC(High[1],fsLength);
    fsDonchianLo = LowestFC(Low[1],fsLength);

    ExitLowestPrice = LowestFC(Low[1],teLength);
    ExitHighestPrice = HighestFC(High[1],teLength);

    Commentary("N="+Text(N));
    Commentary("preEntryPrice="+Text(preEntryPrice));
    Commentary("PreBreakoutFailure="+IIFString(PreBreakoutFailure,"True","False"));

    // 当不使用过滤条件，或者使用过滤条件并且条件为PreBreakoutFailure为True进行后续操作
    If(MarketPosition == 0 && ((!LastProfitableTradeFilter) Or (PreBreakoutFailure)))
    {
        // 突破开仓
        If(High > DonchianHi && TurtleUnits >= 1)
        {
            // 开仓价格取突破上轨+一个价位和最高价之间的较小值，这样能更接近真实情况，并能尽量保证成交
            myEntryPrice = min(high,DonchianHi + MinPoint);
            myEntryPrice = IIF(myEntryPrice < Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
            preEntryPrice = myEntryPrice;
            Buy(TurtleUnits,myEntryPrice);
            SendOrderThisBar = True;
            PreBreakoutFailure = False;
        }

        If(Low < DonchianLo && TurtleUnits >= 1)
        {
            // 开仓价格取突破下轨-一个价位和最低价之间的较大值，这样能更接近真实情况，并能尽量保证成交
            myEntryPrice = max(low,DonchianLo - MinPoint);
            myEntryPrice = IIF(myEntryPrice > Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
            preEntryPrice = myEntryPrice;
            SendOrderThisBar = True;
            SellShort(TurtleUnits,myEntryPrice);
            SendOrderThisBar = True;
            PreBreakoutFailure = False;
        }
    }

    // 长周期突破开仓 Failsafe Breakout point
    If(MarketPosition == 0)
    {
        Commentary("fsDonchianHi="+Text(fsDonchianHi));
        If(High > fsDonchianHi && TurtleUnits >= 1)
        {
            // 开仓价格取突破上轨+一个价位和最高价之间的较小值，这样能更接近真实情况，并能尽量保证成交
            myEntryPrice = min(high,fsDonchianHi + MinPoint);
            myEntryPrice = IIF(myEntryPrice < Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
            preEntryPrice = myEntryPrice;
            Buy(TurtleUnits,myEntryPrice);
            SendOrderThisBar = True;
            PreBreakoutFailure = False;
        }

        Commentary("fsDonchianLo="+Text(fsDonchianLo));
        If(Low < fsDonchianLo && TurtleUnits >= 1)
        {
            // 开仓价格取突破下轨-一个价位和最低价之间的较大值，这样能更接近真实情况，并能尽量保证成交
            myEntryPrice = max(low,fsDonchianLo - MinPoint);
            myEntryPrice = IIF(myEntryPrice > Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
            preEntryPrice = myEntryPrice;
            SellShort(TurtleUnits,myEntryPrice);
            SendOrderThisBar = True;
            PreBreakoutFailure = False;
        }
    }

    If(MarketPosition == 1) // 有多仓的情况
    {
        Commentary("ExitLowestPrice="+Text(ExitLowestPrice));
        If(Low < ExitLowestPrice)
        {
            myExitPrice = max(Low,ExitLowestPrice - MinPoint);
            myExitPrice = IIF(myExitPrice > Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
            Sell(0,myExitPrice);    // 数量用0的情况下将全部平仓
        }Else
        {
            If(preEntryPrice!=InvalidNumeric && TurtleUnits >= 1)
            {
                If(Open >= preEntryPrice + 0.5*N) // 如果开盘就超过设定的1/2N,则直接用开盘价增仓。
                {
                    myEntryPrice = Open;
                    preEntryPrice = myEntryPrice;
                    Buy(TurtleUnits,myEntryPrice);
                    SendOrderThisBar = True;
                }

                while(High >= preEntryPrice + 0.5*N) // 以最高价为标准，判断能进行几次增仓
                {
                    myEntryPrice = preEntryPrice + 0.5 * N;
                    preEntryPrice = myEntryPrice;
                    Buy(TurtleUnits,myEntryPrice);
                    SendOrderThisBar = True;
                }
            }

            // 止损指令
            If(Low <= preEntryPrice - 2 * N && SendOrderThisBar == false) // 加仓Bar不止损
            {
                myExitPrice = preEntryPrice - 2 * N;
                myExitPrice = IIF(myExitPrice > Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
                Sell(0,myExitPrice); // 数量用0的情况下将全部平仓
                PreBreakoutFailure = True;
            }
        }
    }Else If(MarketPosition ==-1) // 有空仓的情况
    {
        // 求出持空仓时离市的条件比较值
        Commentary("ExitHighestPrice="+Text(ExitHighestPrice));
        If(High > ExitHighestPrice)
        {
            myExitPrice = Min(High,ExitHighestPrice + MinPoint);
            myExitPrice = IIF(myExitPrice < Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
            BuyToCover(0,myExitPrice);    // 数量用0的情况下将全部平仓
        }Else
        {
            If(preEntryPrice!=InvalidNumeric && TurtleUnits >= 1)
            {
                If(Open <= preEntryPrice - 0.5*N) // 如果开盘就超过设定的1/2N,则直接用开盘价增仓。
                {
                    myEntryPrice = Open;
                    preEntryPrice = myEntryPrice;
                    SellShort(TurtleUnits,myEntryPrice);
                    SendOrderThisBar = True;
                }

                while(Low <= preEntryPrice - 0.5*N) // 以最低价为标准，判断能进行几次增仓
                {
                    myEntryPrice = preEntryPrice - 0.5 * N;
                    preEntryPrice = myEntryPrice;
                    SellShort(TurtleUnits,myEntryPrice);
                    SendOrderThisBar = True;
                }
            }

            // 止损指令
            If(High >= preEntryPrice + 2 * N &&SendOrderThisBar==false) // 加仓Bar不止损
            {
                myExitPrice = preEntryPrice + 2 * N;
                myExitPrice = IIF(myExitPrice < Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
                BuyToCover(0,myExitPrice); // 数量用0的情况下将全部平仓
                PreBreakoutFailure = True;
            }
        }
    }
End

//------------------------------------------------------------------------
// 编译版本 GS2016.12.18
// 版权所有 TradeBlazer Software 2003－2017
// 更改声明 TradeBlazer Software保留对TradeBlazer平
//          台每一版本的TradeBlazer公式修改和重写的权利
//------------------------------------------------------------------------
